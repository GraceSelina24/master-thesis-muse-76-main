import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const PORT = process.env.PORT || 3001;

// Test database connection
async function testConnection() {
  try {
    await prisma.$connect();
    console.log('Database connection established successfully');
  } catch (error) {
    console.error('Database connection error:', error);
    process.exit(1);
  }
}

testConnection();

const app = express();

// Configure CORS
app.use(cors({
  origin: 'http://localhost:5173',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

app.use(bodyParser.json());

// Add OPTIONS handling for preflight requests
app.options('*', cors());

// Middleware to verify JWT token
const verifyToken = (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    console.error('Token verification failed:', error);
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// Authentication routes
app.post('/api/users/register', async (req, res) => {
  try {
    const { email, password, name } = req.body;
    console.log('Registration attempt:', { email, name });

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create new user
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name: name || email.split('@')[0],
        settings: {
          create: {
            theme: 'system',
            language: 'en',
            weightUnit: 'kg',
            heightUnit: 'cm',
            distanceUnit: 'km',
            calorieUnit: 'kcal',
            fontSize: 'medium',
            emailNotifications: true,
            pushNotifications: true,
            workoutReminders: true,
            mealReminders: true,
            progressUpdates: true,
            goalNotifications: true
          }
        }
      },
      include: {
        settings: true
      }
    });

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Remove password from response
    const { password: _, ...userWithoutPassword } = user;

    console.log('User registered successfully:', userWithoutPassword);
    res.status(201).json({ 
      user: userWithoutPassword,
      token
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'An unexpected error occurred during registration' });
  }
});

// Login route
app.post('/api/users/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    const user = await prisma.user.findUnique({
      where: { email },
      include: {
        settings: true
      }
    });

    if (!user) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Remove password from response
    const { password: _, ...userWithoutPassword } = user;

    res.status(200).json({ 
      user: userWithoutPassword,
      token
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'An error occurred during login' });
  }
});

// Get user profile
app.get('/api/users/me', verifyToken, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.user.id },
      include: {
        settings: true
      }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const { password: _, ...userWithoutPassword } = user;
    res.json(userWithoutPassword);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// User routes
app.get('/api/users/profile/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(user);
  } catch (error) {
    console.error('Error fetching profile:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

app.put('/api/users/profile/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { name } = req.body;

    const user = await prisma.user.update({
      where: { id: userId },
      data: { name },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    res.json(user);
  } catch (error) {
    console.error('Error updating profile:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

// User settings routes
app.get('/api/users/settings/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const settings = await prisma.userSettings.findUnique({
      where: { userId },
    });

    if (!settings) {
      // Return default settings if none exist
      return res.json({
        // App Personalization
        theme: 'system',
        language: 'en',
        weightUnit: 'kg',
        heightUnit: 'cm',
        distanceUnit: 'km',
        calorieUnit: 'kcal',
        fontSize: 'medium',
        
        // Notifications
        pushNotifications: true,
        emailNotifications: true,
        workoutReminders: true,
        mealReminders: true,
        progressUpdates: true,
        reminderTime: '08:00',
        goalNotifications: true,
        
        // Privacy & Security
        twoFactorEnabled: false,
        connectedApps: [],
        dataSharing: {},
        
        // Subscription
        subscriptionStatus: 'free',
        subscriptionEndDate: null,
        paymentMethod: null,
        billingAddress: null,
        
        // Data & Sync
        autoSync: true,
        syncFrequency: 'daily',
        lastBackup: null,
        backupFrequency: 'weekly',
        
        // Accessibility
        screenReaderMode: false,
        textToSpeech: false,
        colorBlindMode: false,
        highContrastMode: false,
        
        // Developer Settings
        debugMode: false,
        apiKeys: [],
        developerMode: false,
        
        // Help & Support
        lastFeedbackDate: null,
        appVersion: '1.0.0',
        
        // Legal
        cookiePreferences: {
          essential: true,
          analytics: true,
          marketing: false
        }
      });
    }

    res.json(settings);
  } catch (error) {
    console.error('Error fetching settings:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

app.put('/api/users/settings/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const updatedSettings = req.body;

    const settings = await prisma.userSettings.upsert({
      where: { userId },
      update: updatedSettings,
      create: {
        userId,
        ...updatedSettings,
      },
    });

    res.json(settings);
  } catch (error) {
    console.error('Error updating settings:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

// Health data routes
app.get('/api/health/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const healthData = await prisma.healthData.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });
    res.json(healthData);
  } catch (error) {
    console.error('Error fetching health data:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

app.post('/api/health/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const healthData = await prisma.healthData.create({
      data: {
        userId,
        ...req.body,
      },
    });
    res.json(healthData);
  } catch (error) {
    console.error('Error creating health data:', error);
    res.status(500).json({ error: 'An unexpected error occurred' });
  }
});

// Get user's meals
app.get('/api/meals/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const meals = await prisma.meal.findMany({
      where: {
        userId: userId,
        date: {
          gte: new Date(new Date().setHours(0, 0, 0, 0)),
          lt: new Date(new Date().setHours(23, 59, 59, 999))
        }
      },
      orderBy: {
        date: 'desc'
      }
    });
    res.json(meals.map(meal => ({
      ...meal,
      type: meal.description?.toLowerCase().includes('breakfast') ? 'breakfast' :
            meal.description?.toLowerCase().includes('lunch') ? 'lunch' :
            meal.description?.toLowerCase().includes('dinner') ? 'dinner' : 'snack'
    })));
  } catch (error) {
    console.error('Error fetching meals:', error);
    res.status(500).json({ error: 'Failed to fetch meals' });
  }
});

// Add a new meal
app.post('/api/meals/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { name, description, calories, protein, carbs, fat, type, date } = req.body;
    
    const meal = await prisma.meal.create({
      data: {
        name,
        description: description || `${type} at ${new Date(date).toLocaleTimeString()}`,
        calories: Number(calories),
        protein: Number(protein) || 0,
        carbs: Number(carbs) || 0,
        fat: Number(fat) || 0,
        date: new Date(date),
        userId
      }
    });
    
    res.status(201).json({
      ...meal,
      type
    });
  } catch (error) {
    console.error('Error adding meal:', error);
    res.status(500).json({ error: 'Failed to add meal' });
  }
});

// Delete a meal
app.delete('/api/meals/:mealId', async (req, res) => {
  try {
    const { mealId } = req.params;
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const meal = await prisma.meal.findUnique({
      where: { id: mealId }
    });

    if (!meal) {
      return res.status(404).json({ error: 'Meal not found' });
    }

    if (meal.userId !== decoded.id) {
      return res.status(403).json({ error: 'Not authorized to delete this meal' });
    }

    await prisma.meal.delete({
      where: { id: mealId }
    });

    res.status(200).json({ message: 'Meal deleted successfully' });
  } catch (error) {
    console.error('Error deleting meal:', error);
    res.status(500).json({ error: 'Failed to delete meal' });
  }
});

// Get user's activities
app.get('/api/workouts/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const activities = await prisma.workout.findMany({
      where: {
        userId: userId,
        date: {
          gte: new Date(new Date().setHours(0, 0, 0, 0)),
          lt: new Date(new Date().setHours(23, 59, 59, 999))
        }
      },
      orderBy: {
        date: 'desc'
      }
    });
    res.json(activities.map(activity => ({
      ...activity,
      type: activity.description?.toLowerCase().includes('run') ? 'running' :
            activity.description?.toLowerCase().includes('walk') ? 'walking' :
            activity.description?.toLowerCase().includes('cycl') ? 'cycling' :
            activity.description?.toLowerCase().includes('swim') ? 'swimming' : 'other'
    })));
  } catch (error) {
    console.error('Error fetching activities:', error);
    res.status(500).json({ error: 'Failed to fetch activities' });
  }
});

// Add a new activity
app.post('/api/workouts/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { name, duration, calories, type, date } = req.body;
    
    const activity = await prisma.workout.create({
      data: {
        name,
        description: `${type} activity`,
        duration: Number(duration),
        calories: Number(calories),
        date: new Date(date),
        userId
      }
    });
    
    res.status(201).json({
      ...activity,
      type
    });
  } catch (error) {
    console.error('Error adding activity:', error);
    res.status(500).json({ error: 'Failed to add activity' });
  }
});

// Delete a workout
app.delete('/api/workouts/:workoutId', async (req, res) => {
  try {
    console.log('Delete workout request received:', {
      workoutId: req.params.workoutId,
      headers: req.headers
    });

    const { workoutId } = req.params;
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      console.log('No token provided');
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    console.log('Token decoded:', decoded);

    const workout = await prisma.workout.findUnique({
      where: { id: workoutId }
    });

    console.log('Found workout:', workout);

    if (!workout) {
      console.log('Workout not found');
      return res.status(404).json({ error: 'Workout not found' });
    }

    if (workout.userId !== decoded.id) {
      console.log('User not authorized to delete this workout');
      return res.status(403).json({ error: 'Not authorized to delete this workout' });
    }

    await prisma.workout.delete({
      where: { id: workoutId }
    });

    console.log('Workout deleted successfully');
    res.status(200).json({ message: 'Workout deleted successfully' });
  } catch (error) {
    console.error('Error deleting workout:', error);
    res.status(500).json({ error: 'Failed to delete workout' });
  }
});

// Test user creation endpoint
app.post('/api/users/create-test', async (req, res) => {
  try {
    const testEmail = 'test@example.com';
    const testPassword = 'password123';

    // Check if test user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email: testEmail }
    });

    if (existingUser) {
      return res.status(200).json({ 
        message: 'Test user already exists',
        user: {
          id: existingUser.id,
          email: existingUser.email,
          name: existingUser.name
        }
      });
    }

    // Create test user if doesn't exist
    const hashedPassword = await bcrypt.hash(testPassword, 10);
    const user = await prisma.user.create({
      data: {
        email: testEmail,
        password: hashedPassword,
        name: 'Test User',
        settings: {
          create: {
            theme: 'light',
            language: 'en',
            emailNotifications: true,
            pushNotifications: true
          }
        }
      },
      include: {
        settings: true
      }
    });

    // Remove password from response
    const { password, ...userWithoutPassword } = user;

    res.status(201).json({ 
      message: 'Test user created successfully',
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Error creating test user:', error);
    res.status(500).json({ error: 'Failed to create test user' });
  }
});

// Get user profile
app.get('/api/profile', verifyToken, async (req, res) => {
  console.log('Profile route hit');
  try {
    const userId = req.user.id;
    console.log('Fetching profile for user:', userId);
    
    // Get user data with settings
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        settings: true
      }
    });

    console.log('User data retrieved:', user ? 'found' : 'not found');

    if (!user) {
      console.log('User not found in database');
      return res.status(404).json({ message: 'User not found' });
    }

    // Format the response
    const profile = {
      name: user.name,
      email: user.email,
      height: user.settings?.height || 0,
      weight: user.settings?.weight || 0,
      age: user.settings?.age || 0,
      gender: user.settings?.gender || 'Not specified',
      activityLevel: user.settings?.activityLevel || 'Not specified',
      dietaryPreferences: user.settings?.dietaryPreferences || [],
      healthGoals: user.settings?.healthGoals || [],
      heightUnit: user.settings?.heightUnit || 'cm',
      weightUnit: user.settings?.weightUnit || 'kg',
      calorieUnit: user.settings?.calorieUnit || 'kcal',
      distanceUnit: user.settings?.distanceUnit || 'km',
      theme: user.settings?.theme || 'system',
      language: user.settings?.language || 'en',
      emailNotifications: user.settings?.emailNotifications || false,
      pushNotifications: user.settings?.pushNotifications || false,
      mealReminders: user.settings?.mealReminders || false,
      workoutReminders: user.settings?.workoutReminders || false,
      progressUpdates: user.settings?.progressUpdates || false,
      goalNotifications: user.settings?.goalNotifications || false,
      subscriptionStatus: user.settings?.subscriptionStatus || 'free',
      subscriptionEndDate: user.settings?.subscriptionEndDate || null
    };

    console.log('Sending profile response:', profile);
    res.json(profile);
  } catch (error) {
    console.error('Error fetching profile:', error);
    res.status(500).json({ message: 'Error fetching profile data', error: error.message });
  }
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

// Handle server shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down server...');
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Shutting down server...');
  await prisma.$disconnect();
  process.exit(0);
}); 